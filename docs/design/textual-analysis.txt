
BORC
	Is a set of command line utilities and libraries for building software products based on a simple set of rules.

	Inputs:
		- Source Files 
		- Build descriptions
		
	Output:
		- Software artifacts.

	Possible use-cases:
		- Cleanly manage the asset pipeline for a game.
		- Orchestrate the build proccess for a whole software product line, composed of many programs.
		- Manage the building for a multi-technology project.
		- Automatically import dependencies from version control systems.

Concept Analysis

1. Project:
	- It's the main entity in the build description file.
	- Has a collection of many sub-projects, targets, tasks, and configurations.
	
2. Target:
	- Is a software artifact that has to be explicity generated by the build manager.
	- Has a Name and a Version.
		- The Name is a Identifier-Like value.
		- The Version is a Semantic Versioning value [TODO: other versioning schemes? how they affect us?]
		- In Windows, the version must be embedded in the generated binary (EXE or DLL) via Windows Resources.
	- Has dependencies:
		- Those dependencies can be defined in the same project, or defined externally and imported.
			- When defined internally (locally), are specified in detail in the same project.
			- When defined externally:
				- Their definitions exists outside the project.
				- Their contents can be fetched from a path, a url or a repository.
				- Can be built as part of the project build proccess.
				- Can be pre-built and used directly in the project build proccess.
		- Can be run-time or build-time dependencies:
			- A run-time dependency is a Module that is necesary when the user is running the program or another run-time based library dependency.
			- A build-time dependency is a Module that is necesary when the developer are building the program or library.
	- Has a type:
		- program: The Target is a executable module.
		- library: The Target is a library that can be a dependency for another program or library.
		- pack: A file that holds another files. Suitable for packaging the assets for a Game.
		- documentation: A target that represents a generated documentation. 
			- An example is Doxygen-based documentations.
	- Is composed from many sources files.
		- They can be:
			- Source Code files.
			- Intermediate-Format XML files used for generate other files during build-time.
			- Transform images, sounds, and another multimedia resources from one format to another format more suitable for run-time performances.
			- In short, to transform any source format file to another target format file, suitable for run-time consumption.
		- Those source files can be transformed many times during the build proccess [need to find a way to express a artifact production pipeline clearly].
		- To map a source file on a target file we need a Mapper (AKA Compilers for source code files).
		- To reduce many target files into a target, we need a Reducer (AKA Linker for source code files).

3. Task:
	- Is a set of coordinated steps to acomplish some action.
	- They doesn't directly generate an artifact (Target must be used to directly generate an artifact).
	- Some default tasks are:
		- build: Build a set of targets.
		- clean: Clean all the intermediate objects generated for a build.
		- install: Installs all the targets to a pre-configured location.
		- configure: Detect available system-level, or project-level build toolchains (yes, custom toolchains can be defined directly in the project itself).
		- run: Runs an executable target.
			- When no executable is specified, the default executable is executed.
	- Tasks can be defined by the developer.
		- [TODO]: Define the custom task definition format-language, etc.
		
4. Configuration
	- Is a set of properties that drive the way different variations of the artifacts can be defined.
	- By default, exists the Debug and Release configurations:
		- The Debug Configuration is a configuration suitable for development.
		- The Release Configuration is a configuration suitable for production/deployment.

5. Toolchains
	- A set of tools that map source files to target files.
	- In other words, Toolchains provides Mappers and Reducers.
	- Based on their physical location, can be System Toolchains or Project Toolchains
		- System Toolchains tipically contain Compilers, Linkers, Assemblers, Compressors, and another tools.
		- Project Toolchains are custom toolchains that converts from one format to another one.
			- A Project can invoke toolchains from another child toolchains.
			- Example project toolchain: A tool that generate a source code file for any physical file, for embeddeding it directly in the executable.
	- A BORC project can be built using many System Toolchains at the same time.
		- This is useful for a project targeting multiple platforms, like Desktop, Mobile and Web.
	- 
	
6. Templates
	- A set of pre-constructed projects, targets, tasks, etc. for aiding the developer to put more value on their software projects.
	

Functional Requirements:
	- Integration with other build systems (CMake, Gradle, etc).
	- Support for C/C++ projects
		- The libraries can be static or dynamic.
		- Dependening on the compiler used, the following variations are avaiable:
			- 32, 64 bits, etc.
			- x86, ARM, etc.
		- Automatic management for internal and external dependencies.
			- Internal dependency: Dependency defined by the current project itself.
			- External dependency: Dependency defined outsidfe the project itself:
				- Defined by BORC itself
				- Defined by third parties.
		- Flexible and transparent build support
			- Different compiler support (GCC, Visual C++, Intel C++, etc).
			- Compiler independent
			- Debug, Release and others.
			- Static and Shared Libraries.
			- Static and Shared Runtime Libraries.
			
	
Non-Functional Requirements:
	- Ultra-Fast builds
		- Smart, Parallel builds by default.
		- Uses Precompiled-Headers automatically.
	- Plugin-Based architecture.
	- Convention-over-Configuration.
		- Safe defaults.
	- Based on Functional concepts.
	- Deterministic Builds 
		- It has to generate the same results regardless of the current status of the generated intermediate artifacts (even if those are corrupted).
	- Support for Windows and Linux.
	
Scenarios 
	- Build a simple command line application, consisting in many files 
	- Build a medium-sized GUI application, consisting in many files, some internal and external dependencies.
	- 
	
Workflow Definition (Users Histories, expressed by command-line examples)
	- As a [Developer] I want to [generate a blank project] In order to [later start to add components].
		$ borc generate project --template=hello-world --lang=cpp17 my-hello-world
		This will generate a project with the following structure:

	- As a [Developer] I want to [generate a skeleton project] In order to [start the development of a new software project].
		$ borc generate project --template=hello-world --lang=cpp17 my-hello-world
		This will generate a project with the following structure:
	
	- As a [Developer] I want to [build a project] In order to [test the project], [ship the project], [pack the project].
		$ 
	
Physical File Layout
	- BORC definitions are expressed in text files.
	- The main definition is the Project Definition file, named 'main.borc' (this can't be overrided).
	- The definition of the other entities can be splitted in many files (one of each entity).
		- For example, an executable can have their own borc definition file (the same for libraries, packs, etc)
		- Another example: A complex task can be defined in it's own borc definition file.
	- The borc command-line utilities automatically scans all the non-hidden folders for definitions.
		- [HINT]: This is a possible performance-killer.
	